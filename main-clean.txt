// main.go
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"math"
	"mime"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

var db *sql.DB

// Secrets must be provided via environment
var jwtSecret = getenv("JWT_SECRET", "")
var encKeyHex = getenv("ENC_KEY_HEX", "")

type Account struct {
	ID         int64  `json:"id"`
	UserID     int64  `json:"user_id"`
	Number     string `json:"number"`
	BalanceCts int64  `json:"balance_cents"`
}

func main() {
	if jwtSecret == "" {
		log.Fatal("JWT_SECRET must be set")
	}
	if encKeyHex == "" {
		log.Println("WARN: ENC_KEY_HEX not set - encrypt endpoint will be disabled")
	}

	user := getenv("DB_USER", "root")
	pass := getenv("DB_PASS", "root")
	host := getenv("DB_HOST", "127.0.0.1")
	database := getenv("DB_NAME", "bankdb")

	dsn := fmt.Sprintf("%s:%s@tcp(%s:3306)/%s?parseTime=true", user, pass, host, database)
	var err error
	db, err = sql.Open("mysql", dsn)
	if err != nil {
		log.Fatalf("db open: %v", err)
	}
	if err = db.Ping(); err != nil {
		log.Printf("WARN: db ping failed: %v", err)
	}

	r := gin.Default()

	r.GET("/", home)
	r.GET("/ping", ping)

	r.POST("/auth/login", login) // secure login -> JWT with exp

	auth := r.Group("/", authMiddleware())
	{
		auth.GET("/me/balance", meBalance)
		auth.POST("/transfer", transfer)
		auth.GET("/accounts/:id", getAccountByID)
	}

	// safe utilities
	r.GET("/hash", sha256Hash)
	r.POST("/encrypt", encryptAESGCM)

	// safe upload example (commented out endpoint if you don't want it exposed)
	r.POST("/upload", uploadHandler)

	addr := getenv("ADDR", ":9000")
	log.Printf("Listening at %s", addr)
	log.Fatal(r.Run(addr))
}

func getenv(k, d string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return d
}

func ping(c *gin.Context) { c.String(http.StatusOK, "pong") }

func home(c *gin.Context) {
	html := `<html><head><title>Banking Lab - Secure</title></head><body>
	<h3>Golang Banking Secure Lab (Gin)</h3>
	<ul>
	<li>POST /auth/login (username, password) → returns JWT (expires)</li>
	<li>GET /me/balance → JWT required</li>
	<li>POST /transfer → JWT + ownership checks</li>
	<li>GET /accounts/:id → JWT + ownership check</li>
	<li>GET /hash?data=x → SHA-256 hex</li>
	<li>POST /encrypt (data) → AES-GCM (returns hex)</li>
	<li>POST /upload → secure upload</li>
	</ul></body></html>`
	c.Data(200, "text/html; charset=utf-8", []byte(html))
}

// ---------------- auth ----------------

func login(c *gin.Context) {
	username := c.PostForm("username")
	password := c.PostForm("password")
	if username == "" || password == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "username & password required"})
		return
	}

	// Example user lookup: table users(id, username, password_hash)
	var id int64
	var pwHash string
	err := db.QueryRow("SELECT id, password_hash FROM users WHERE username = ? LIMIT 1", username).Scan(&id, &pwHash)
	if err != nil {
		// avoid leaking which usernames exist
		log.Printf("login lookup err: %v", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
		return
	}

	if bcrypt.CompareHashAndPassword([]byte(pwHash), []byte(password)) != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
		return
	}

	claims := jwt.MapClaims{
		"sub": id,
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(24 * time.Hour).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	signed, err := token.SignedString([]byte(jwtSecret))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "token generation error"})
		return
	}
	c.JSON(200, gin.H{"token": signed})
}

func authMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		auth := c.GetHeader("Authorization")
		if strings.HasPrefix(auth, "Bearer ") {
			auth = strings.TrimPrefix(auth, "Bearer ")
		}
		if auth == "" {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing token"})
			return
		}
		t, err := jwt.Parse(auth, func(t *jwt.Token) (interface{}, error) {
			if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method")
			}
			return []byte(jwtSecret), nil
		})
		if err != nil || !t.Valid {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
			return
		}
		claims, ok := t.Claims.(jwt.MapClaims)
		if !ok {
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid claims"})
			return
		}
		sub := claims["sub"]
		var uid int64
		switch v := sub.(type) {
		case float64:
			uid = int64(v)
		case int64:
			uid = v
		case string:
			uid, _ = strconv.ParseInt(v, 10, 64)
		default:
			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid sub"})
			return
		}
		c.Set("user_id", uid)
		c.Next()
	}
}

func getUserID(c *gin.Context) (int64, error) {
	v, ok := c.Get("user_id")
	if !ok {
		return 0, errors.New("not authenticated")
	}
	uid, ok := v.(int64)
	if !ok {
		return 0, errors.New("invalid user id")
	}
	return uid, nil
}

// ---------------- accounts ----------------

func meBalance(c *gin.Context) {
	uid, err := getUserID(c)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthenticated"})
		return
	}
	var bal int64
	err = db.QueryRow("SELECT balance_cents FROM accounts WHERE user_id = ? LIMIT 1", uid).Scan(&bal)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(200, gin.H{"balance_cents": 0})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
		return
	}
	c.JSON(200, gin.H{"balance_cents": bal})
}

func getAccountByID(c *gin.Context) {
	uid, _ := getUserID(c)
	idStr := c.Param("id")
	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
		return
	}
	var acc Account
	err = db.QueryRow("SELECT id, user_id, number, balance_cents FROM accounts WHERE id = ?", id).
		Scan(&acc.ID, &acc.UserID, &acc.Number, &acc.BalanceCts)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "db error"})
		return
	}
	if acc.UserID != uid {
		c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
		return
	}
	c.JSON(200, acc)
}

// transfer expects amount as decimal string e.g. "10.50"
func transfer(c *gin.Context) {
	uid, _ := getUserID(c)
	fromID, err := strconv.ParseInt(c.PostForm("from_account_id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid from_account_id"})
		return
	}
	toID, err := strconv.ParseInt(c.PostForm("to_account_id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid to_account_id"})
		return
	}
	amountStr := c.PostForm("amount")
	if amountStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "amount required"})
		return
	}
	amtF, err := strconv.ParseFloat(amountStr, 64)
	if err != nil || amtF <= 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid amount"})
		return
	}
	amountCts := int64(math.Round(amtF * 100))

	// ownership check
	var owner int64
	err = db.QueryRow("SELECT user_id FROM accounts WHERE id = ?", fromID).Scan(&owner)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "from account invalid"})
		return
	}
	if owner != uid {
		c.JSON(http.StatusForbidden, gin.H{"error": "not owner of from account"})
		return
	}

	tx, err := db.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "db tx error"})
		return
	}
	defer tx.Rollback()

	var fromBal int64
	err = tx.QueryRow("SELECT balance_cents FROM accounts WHERE id = ? FOR UPDATE", fromID).Scan(&fromBal)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "db read error"})
		return
	}
	if fromBal < amountCts {
		c.JSON(http.StatusBadRequest, gin.H{"error": "insufficient funds"})
		return
	}

	_, err = tx.Exec("UPDATE accounts SET balance_cents = balance_cents - ? WHERE id = ?", amountCts, fromID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "update error"})
		return
	}
	_, err = tx.Exec("UPDATE accounts SET balance_cents = balance_cents + ? WHERE id = ?", amountCts, toID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "update error"})
		return
	}
	_, err = tx.Exec("INSERT INTO transactions (from_account_id, to_account_id, amount_cents, created_at) VALUES (?, ?, ?, NOW())",
		fromID, toID, amountCts)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "insert tx error"})
		return
	}
	if err := tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "commit error"})
		return
	}
	c.JSON(200, gin.H{"status": "ok"})
}

// ---------------- utilities ----------------

func sha256Hash(c *gin.Context) {
	data := c.Query("data")
	h := sha256.Sum256([]byte(data))
	c.String(200, hex.EncodeToString(h[:]))
}

func encryptAESGCM(c *gin.Context) {
	if encKeyHex == "" {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "encryption key not configured"})
		return
	}
	key, err := hex.DecodeString(encKeyHex)
	if err != nil || len(key) != 32 {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid encryption key"})
		return
	}
	plaintext := []byte(c.PostForm("data"))
	if len(plaintext) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "data required"})
		return
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "cipher error"})
		return
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "gcm error"})
		return
	}
	nonce := make([]byte, aesgcm.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "nonce error"})
		return
	}
	ct := aesgcm.Seal(nil, nonce, plaintext, nil)
	out := append(nonce, ct...)
	c.String(200, hex.EncodeToString(out))
}

// ---------------- upload (safe) ----------------

func uploadHandler(c *gin.Context) {
	dstDir := "./uploads"
	path, err := saveUploadedFileSafe(c, "file", dstDir)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(200, gin.H{"saved": path})
}

func saveUploadedFileSafe(c *gin.Context, formField, dstDir string) (string, error) {
	f, err := c.FormFile(formField)
	if err != nil {
		return "", err
	}
	orig := filepath.Base(f.Filename)
	ext := filepath.Ext(orig)
	if ext == "" {
		ct := f.Header.Get("Content-Type")
		exts, _ := mime.ExtensionsByType(ct)
		if len(exts) > 0 {
			ext = exts[0]
		}
	}
	name := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '.' || r == '_' || r == '-' {
			return r
		}
		return -1
	}, orig)
	if name == "" {
		name = fmt.Sprintf("upload_%d%s", time.Now().Unix(), ext)
	}
	if err := os.MkdirAll(dstDir, 0o755); err != nil {
		return "", err
	}
	dst := filepath.Join(dstDir, name)
	if err := c.SaveUploadedFile(f, dst); err != nil {
		return "", err
	}
	return dst, nil
}